---
title: "Ex009_main_analysis"
author: Bin He
created: 19 oct 2017
output: html_notebook
---

```{r global_options, echo=FALSE}
knitr::opts_chunk$set(message=FALSE, echo=FALSE, cache=TRUE, comment=NA)
```

# Goal

1. Characterize the **genome-wide** transcriptional response to inorganic phosphate starvation in _C. glabrata_. Compare this to the Pho4-dependent gene induction identified in the _pho80∆_ background that causes constitutive activation of Pho4.
    
   > previously I used RNAseq in _pho80∆_ to identify genes induced by Pho4, while measuring Pho4 binding profile under physiological starvation conditions. This dataset will allow me to revisit some of the genes deemed bound but not induced by Pho4 in the previous dataset, to see if they are actually induced under starvation.

1. in addition to identifying the genes that respond to the starvation, but also their kinetics.
    
   > this is motivated by Barkai group's Cell Reports study, where they showed that PHO genes in _S. cerevisiae_ were induced in two big waves following starvation. I want to see if similar dynamics can be observed in _C. glabrata_
   
# Experiment set up

In Ex009, I performed time-course transcriptome profiling following inorganic phosphate starvation in two genetic background, namely the wild-type and _pho4∆_. The purpose of doing this in _pho4∆_ is to distinguish Pho4-dependent vs Pho4-independent gene induction.

The time-course includes a pre-stress (rich media) condition and a series of post-stress time points. The sampling density on the time axis is denser in the beginning, then gradually becoming sparser, in contrast to the regular interval designed used in Barkai's study. This is so that I can focus on the early time points while restricting the total number of samples I need to collect and process.

The sample sheet is documented [here](../data/sample_sheet/Ex009_experiment_set_up_20171019.csv)

# Analyses

## Prepare data

```{r load_libraries}
require(ggplot2)       ## for plotting
require(cowplot)       ## for some useful defaults in ggplot2
require(limma)         ## for differential gene expression analysis
require(data.table)    ## for fast importing and manipulating data tables
require(edgeR)         ## for DGEList()
require(RColorBrewer)  ## for plotting
```

```{r load_data}
# raw data count
raw <- fread("../data/gene_count/Ex009_reads_per_transcript_2017-10-18.txt")
setkey(raw, "gene.names")
# sample sheet
sample <- fread("../data/sample_sheet/Ex009_experiment_set_up_20171019.csv")
# annotation
anno.file <- fread("../data/annotation/C_glabrata_gene_for_mapping_s02-m07-r04.bed")
names(anno.file) <- c("Chr","Start","End","GeneID","Not.Use","Strand","GeneName","Type.of.Gene")
anno <- anno.file[,c("Chr","GeneID","GeneName","Type.of.Gene")]
setkey(anno, "GeneID")
```

```{r prepare_data}
# filter dataset to remove very lowly expressed genes
# 1. examine the distribution of reads for each gene across all samples, to establish a threshold
S <- rowSums(raw[,1:40])
plot(density(log10(S)))
sprintf("The number of genes with less than 40 total counts across 40 samples, i.e. 1 read per sample on average is %d, and those with less than 100 total counts, or 2.5 reads per sample, is %d", sum(S<=40), sum(S<=100))
print("Let's try 100 reads as a cutoff for dropping genes with low or no expression")

# 2. filter dataset
isexpr <- (S <= 100)
use.genes <- grepl("ncRNA|ORF|pseudogene", anno$Type.of.Gene)
use <- (!isexpr & use.genes)
mat <- as.matrix(raw[use, 1:40])
anno.all <- anno; anno <- anno.all[use]

# 3. write out the filtered table
write.table(as.data.frame(raw[use]), file = paste("../data/gene_count/Ex009_reads_per_transcript_filtered_", Sys.Date(), ".txt", sep = ""), quote = FALSE, row.names = FALSE)
```

## Exploratary analysis

_Goal_

- visualize the between sample variation in the raw read count distribution, so as to assess the need of normalization and to choose the appropriate method

_Reference_

[RUVSeq manual on Bioconductor](http://bioconductor.org/packages/release/bioc/vignettes/RUVSeq/inst/doc/RUVSeq.pdf)

_Analyses_

```{r explorartory}
# load necessary packages
require(RUVSeq)
require(EDASeq)
layout( matrix(c(1,2), ncol = 2), widths = c(2,1) )
# visualize the between sample variation
print("Non-normalized")
plotRLE(mat, outline=FALSE, ylim= c(-4, 4), cex.axis = 0.5, las = 3)
plotPCA(mat, cex=1.2)
# attempt upper quantile normalization
print("Upper-quantile normalized")
set <- newSeqExpressionSet(counts = mat)
set <- betweenLaneNormalization(set, which="upper")
plotRLE(set, outline=FALSE, ylim=c(-4, 4))
plotPCA(set, cex=1.2)
# try TMM normalization
print("TMM normalized")
norm.fact <- calcNormFactors(mat, method = "TMM")
set1 <- mat * norm.fact
plotRLE(set1, outline=FALSE, ylim= c(-4, 4), cex.axis = 0.5, las = 3)
plotPCA(set1, cex=1.2)
## why isn't TMM "normalizing" across samples?
```

## LIMMA pipeline

```{r normalize_data}
# 1. construct count matrix
dge <- DGEList( counts = mat, genes = anno )
# 2. perform TMM normalization
dge <- calcNormFactors(dge)
# 3. calculate log transformed, normalized counts
logCPM <- cpm( dge, normalized.lib.sizes = TRUE, log = TRUE, prior.count = 0.5 ) # note that 
```