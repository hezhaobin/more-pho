---
title: "Ex009_main_analysis"
author: Bin He
created: 19 oct 2017
output: html_notebook
---

```{r global_options, echo=FALSE}
knitr::opts_chunk$set(message=FALSE, echo=FALSE, cache=TRUE, comment=NA)
```

# Goal

1. Characterize the **genome-wide** transcriptional response to inorganic phosphate starvation in _C. glabrata_. Compare this to the Pho4-dependent gene induction identified in the _pho80∆_ background that causes constitutive activation of Pho4.
    
   > previously I used RNAseq in _pho80∆_ to identify genes induced by Pho4, while measuring Pho4 binding profile under physiological starvation conditions. This dataset will allow me to revisit some of the genes deemed bound but not induced by Pho4 in the previous dataset, to see if they are actually induced under starvation.

1. in addition to identifying the genes that respond to the starvation, but also their kinetics.
    
   > this is motivated by Barkai group's Cell Reports study, where they showed that PHO genes in _S. cerevisiae_ were induced in two big waves following starvation. I want to see if similar dynamics can be observed in _C. glabrata_
   
# Experiment set up

In Ex009, I performed time-course transcriptome profiling following inorganic phosphate starvation in two genetic background, namely the wild-type and _pho4∆_. The purpose of doing this in _pho4∆_ is to distinguish Pho4-dependent vs Pho4-independent gene induction.

The time-course includes a pre-stress (rich media) condition and a series of post-stress time points. The sampling density on the time axis is denser in the beginning, then gradually becoming sparser, in contrast to the regular interval designed used in Barkai's study. This is so that I can focus on the early time points while restricting the total number of samples I need to collect and process.

The sample sheet is documented [here](../data/sample_sheet/Ex009_experiment_set_up_20171019.csv)

# Analyses

## Prepare data

```{r load_libraries}
require(ggplot2)       ## for plotting
require(cowplot)       ## for some useful defaults in ggplot2
require(limma)         ## for differential gene expression analysis
require(data.table)    ## for fast importing and manipulating data tables
require(edgeR)         ## for DGEList()
require(RColorBrewer)  ## for plotting
require(EDASeq)        ## for exploratory analysis
```

```{r load_data}
# raw data count
raw <- fread("../data/gene_count/Ex009_reads_per_transcript_2017-10-18.txt")
# sample sheet
sample <- fread("../data/sample_sheet/Ex009_experiment_set_up_20171019.csv")
# rearrange the columns in `raw` according to the samples order in `sample`
ind <- match( c(sample$Sample, "gene.names"), names(raw) )
raw <- raw[,ind,with=FALSE]
# annotation
anno.file <- fread("../data/annotation/C_glabrata_gene_for_mapping_s02-m07-r04.bed")
names(anno.file) <- c("Chr","Start","End","GeneID","Not.Use","Strand","GeneName","Type.of.Gene")
anno <- anno.file[,c("Chr","GeneID","GeneName","Type.of.Gene")]
setkey(anno, "GeneID")
```

```{r prepare_data}
# filter dataset to remove very lowly expressed genes
# 1. examine the distribution of reads for each gene across all samples, to establish a threshold
S <- rowSums(raw[,1:40])
plot(density(log10(S)))
sprintf("The number of genes with less than 40 total counts across 40 samples, i.e. 1 read per sample on average is %d, and those with less than 100 total counts, or 2.5 reads per sample, is %d", sum(S<=40), sum(S<=100))
print("Let's try 40 reads as a cutoff for dropping genes with low or no expression")

# 2. filter dataset
isexpr <- (S <= 40)
use.genes <- grepl("ncRNA|ORF|pseudogene", anno$Type.of.Gene)
use <- (!isexpr & use.genes)
mat <- as.matrix(raw[use, 1:40])
anno.all <- anno; anno <- anno.all[use]

# 3. write out the filtered table (uncomment if changes are made to the filtering steps above)
#write.table(as.data.frame(raw[use]), file = paste("../data/gene_count/Ex009_reads_per_transcript_filtered_", Sys.Date(), ".txt", sep = ""), quote = FALSE, row.names = FALSE)
```

## Exploratary analysis

_Goal_

- visualize the between sample variation in the raw read count distribution, so as to assess the need of normalization and to choose the appropriate method

_Reference_

[RUVSeq manual on Bioconductor](http://bioconductor.org/packages/release/bioc/vignettes/RUVSeq/inst/doc/RUVSeq.pdf)

_Analyses_

```{r explore_normalization, fig.width=10, fig.height=5}
# visualize the between sample variation pre-normalization
print("Non-normalized")
plotRLE(mat, outline=FALSE, ylim= c(-4, 4), cex.axis = 0.5, las = 3)
title(main = "non-normalized", xlab = "sample", ylab = "log2 ratio of expression")

# try upper quantile normalization
print("Upper-quantile normalized")
set1 <- betweenLaneNormalization(mat, which="upper")
plotRLE(set1, outline=FALSE, ylim=c(-4, 4), cex.axis = 0.5, las = 3)
title(main = "upperquartile normalized", xlab = "sample", ylab = "log2 ratio of expression")

# try full quantile normalization
print("Full-quantile normalized")
set2 <- betweenLaneNormalization(mat, which="full")
plotRLE(set2, outline=FALSE, ylim=c(-4, 4), cex.axis = 0.5, las = 3)
title(main = "full quantile normalized", xlab = "sample", ylab = "log2 ratio of expression")

# try TMM normalization
# 1. construct count matrix
dge <- DGEList( counts = mat, genes = anno )
# 2. perform TMM normalization
dge <- calcNormFactors(dge)
# 3. calculate log transformed, normalized counts
cpm.o <- cpm( dge, normalized.lib.sizes = FALSE, log = FALSE, prior.count = 0.5) # unnormalized
cpm.n <- cpm( dge, normalized.lib.sizes = TRUE, log = FALSE, prior.count = 0.5 ) # normalized
plotRLE(cpm.o, outline=FALSE, ylim=c(-4, 4), cex.axis = 0.5, las = 3)
title(main = "library size normalized", xlab = "sample", ylab = "log2 ratio of expression")
plotRLE(cpm.n, outline=FALSE, ylim=c(-4, 4), cex.axis = 0.5, las = 3)
title(main = "TMM normalized", xlab = "sample", ylab = "log2 ratio of expression")
layout( matrix(1:2, ncol = 2) )
boxplot(lcpm.o, las = 2, cex = 0.7, main = "Un-normalized data distribution")
boxplot(lcpm.n, las = 2, cex = 0.7, main = "Normalized data distribution")
```

**Conclusion**

All three methods tried, i.e. TMM, upperquartile and full quantile normalization effectively homogenizes the distribution of log expression ratios.

## LIMMA pipeline

```{r normalize_data}
# use TMM to normalize data
lcpm <- cpm( dge, normalized.lib.sizes = TRUE, log = TRUE, prior.count = 0.5)
rownames(lcpm) <- anno$GeneID
```